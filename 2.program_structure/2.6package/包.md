# package（包）
“为了支持模块化、封装、单独编译和代码重用”

一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包gopl.io/ch1/helloworld对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld

每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问

如目录下的tempconv、conv文件所示，两个文件均属于包tempconv，一些变量声明、常量等定义性代码放在tempconv中，而转换函数则置于conv中（可以类比c++的头文件.h和实现文件.cpp）

要将摄氏温度转换为华氏温度，需要先用import语句导入tempconv包，然后就可以使用下面的代码进行转换：
```
fmt.Println(tempconv.CToF(tempconv.BoilingC)) // "212°F"
```

## 包的初始化
包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：
```
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
```
如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。

对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数（有点像java 单测中使用@Before修饰的方法）
```
func init() { /* ... */ }
```
初始化工作遵循自下而上（被依赖的先初始化）

以下是一个使用init函数的例子：
```
package popcount

// pc[i] is the population count of i.
var pc [256]byte

func init() {
    for i := range pc {
        pc[i] = pc[i/2] + byte(i&1)
    }
}
````
也可以通过匿名函数实现（func() 返回类型 { 函数体 }）：
```
// pc[i] is the population count of i.
var pc [256]byte = func() (pc [256]byte) {
    for i := range pc {
        pc[i] = pc[i/2] + byte(i&1)
    }
    return
}()
```
