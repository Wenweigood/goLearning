## 变量
变量声明格式
```
var 变量名字 类型 = 表达式
var intvalue int = 1
```
其中“类型”或“= 表达式”两个部分可以省略其中的一个。
1. 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。
2. 如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

因此go语言中不存在未初始化的变量

### 一个声明语句中同时声明一组变量
---
可以在，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：
```
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```
在package级别声明的变量会在main函数入口前被初始化，函数内的局部变量则是到执行处才初始化

### 一组变量也可以由一个函数初始化
---
由函数返回的多个返回值初始化：
```
var f, err = os.Open(name) // os.Open returns a file and an error
```
### 短变量声明
---
```
变量名字 := 表达式
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```
变量类型根据表达式自动推导

短变量声明语句也可以声明一组变量：
```
i, j := 0, 1
```

拓展：go语言的多值赋值
```
//交换a和b的值
a, b = b, a
```
简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为

在下面的代码中，第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，然后对已经声明的err进行了赋值操作:
```
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```
注意，简短变量声明语句中必须至少要声明一个新的变量，否则无法编译通过

简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量

### 指针
---
```
x := 1 //赋值变量x
p := &x         // 取x的地址赋予p，此时p类型为 *int（c++中则称为int*），p即x的指针
fmt.Println(*p) // "1"
*p = 2          // *p可作为左值，用以更新指针指向的值，这里与 x = 2 等价
fmt.Println(x)  // "2"
```

go语言中可以对指针进行操作，但仅限于指针指向的内容的操作，无法直接操作指针（如++）改变其指向
```
func incr(p *int) int {
    *p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
    return *p
}

v := 1
incr(&v)              // side effect: v is now 2
fmt.Println(incr(&v)) // "3" (and v is 3)
```

## new函数
表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T
```
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```

每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：
```
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```
当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和[0]int，有可能有相同的地址（依赖具体的语言实现）（谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请见runtime.SetFinalizer函数相关文档）

***注意，new只是一个预定义函数，而非关键字，然而new被自定义后，在作用域范围内无法使用内置的new函数***

### 变量的生命周期
---
package一级的变量生命周期和程序运行一致；局部变量的生命周期自声明创建起，至不再被引用为止

go的垃圾回收：基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。**也就是说，变量的有效周期只取决于是否可达**

编译器为变量分配堆内存和栈内存不取决于 ***var*** 或 ***new*** 的声明方式：
```
var global *int

func f() {
    var x int
    x = 1
    global = &x
    //x必须在堆上分配，因为函数返回后仍被引用
}

func g() {
    y := new(int)
    *y = 1
    //y既可以在栈上分配也可以在堆上分配（若在堆上分配则函数返回后由回收器回收）
}
```